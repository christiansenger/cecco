/*
   Copyright 2025 Christian Senger <senger@inue.uni-stuttgart.de>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   v1.0
*/

/*
How to create irreducible polynomials:
http://magma.maths.usyd.edu.au/calc/

(1) To just use the standard Conway polynomial suggested by Magma (primitive),
example for degree 6 poly over F2:
p:=2; m:=6; F:=GaloisField(p);
P<x>:=PolynomialRing(F);
px:=IrreduciblePolynomial(F, m);
px;
Reverse(Coefficients(px));

(2) To pick a random polynomial (not necessarily primitive), example for degree
6 poly over F3:
p:=3; m:=6; F:=GaloisField(p); P<x>:=PolynomialRing(F);
repeat
    px:=elt<P|1>;
    for i in [0..m] do
        px+:=Random(F)*x^i;
    end for;
until Degree(px) eq m and IsIrreducible(px);
px:=Normalize(px);
Reverse(Coefficients(px));

Besides irreducible, polynomials must be monic (for modular reduction to work
properly). Use polys as follows:

#define F729 Fq<3, MOD{1, 0, 2, 0, 1, 2, 2}> // MSB left, x^6 + 2*x^4 + x^2 + 2*x + 2

Careful: a polynomial of degree m (having m+1 coefficients) specifies the a field extension of
degree m, in the example F_{3^6}.

// subfields (if needed): all divisors m0 of m allowed, subfield size is p^m0
#define F3 SF<F729, 1>
#define F9 SF<F729, 2>
#define F27 SF<F729, 3>

... then F729-elements can be generated by, e.g., F729(12), F9-elements by F9(5).
*/

#ifndef FIELDS_HPP
#define FIELDS_HPP

//#define USE_LUTS_FOR_FP_FOR_FP
#define COMPRESS_LUTS_FROM_Q 512

#include <array>
#include <cassert>
#include <random>
#include <string>
#include <type_traits>

#include "helpers.hpp"
#include "vectors.hpp"

namespace std {

std::string to_string(const InfInt& val) { return val.toString(); }

};  // namespace std

namespace ECC {

// dummy base to "protect" CRTP operator overloads (cannot be instantiated)
class Base {
   protected:
    Base() = default;
};

// base class in Curiously Recurring Template Pattern (CRTP)
template <class T>
class Field : public Base {
   public:
    /* destructor */
    virtual ~Field() noexcept = default;

    /* assignment operators */
    virtual T& operator=(int l) = 0;
    virtual T& operator=(const T& rhs) noexcept = 0;
    virtual T& operator=(T&& rhs) noexcept = 0;

    /* comparison */
    virtual bool operator==(const T& rhs) const noexcept = 0;
    virtual bool operator!=(const T& rhs) const noexcept = 0;

    /* operations */
    virtual T operator+() const noexcept = 0;
    virtual T operator-() const& noexcept = 0;
    virtual T& operator-() && noexcept = 0;

    /* operational assignments */
    virtual T& operator+=(const T& rhs) noexcept = 0;
    virtual T& operator-=(const T& rhs) noexcept = 0;
    virtual T& operator*=(const T& rhs) noexcept = 0;
    virtual T& operator/=(const T& rhs) = 0;

    /* randomization */
    virtual void randomize() = 0;
    virtual void randomize_force_change() = 0;

    /* getters */
    virtual uint16_t get_multiplicative_order() = 0;
    virtual uint16_t get_additive_order() noexcept = 0;
    virtual std::string get_unique_ID() const noexcept = 0;  // get a unique ID for each element

    /* properties */
    virtual bool has_positive_sign() const = 0;
    virtual bool is_zero() const = 0;
};

/* free functions wrt. Field */

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator+(T lhs, const T& rhs) noexcept
    requires(b)
{
    lhs += rhs;
    return lhs;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator+(const T& lhs, T&& rhs) noexcept
    requires(b)
{
    T res(std::forward<T>(rhs));
    res += lhs;
    return res;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator-(T lhs, const T& rhs) noexcept
    requires(b)
{
    lhs -= rhs;
    return lhs;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator-(const T& lhs, T&& rhs) noexcept
    requires(b)
{
    T res(std::forward<T>(rhs));
    res -= lhs;
    return res;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator*(T lhs, const T& rhs) noexcept
    requires(b)
{
    lhs *= rhs;
    return lhs;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator*(const T& lhs, T&& rhs) noexcept
    requires(b)
{
    T res(std::forward<T>(rhs));
    res *= lhs;
    return res;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator*(const T& lhs, uint16_t rhs) noexcept
    requires(b)
{
    T temp = lhs;
    temp *= rhs;
    return temp;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator*(uint16_t lhs, const T& rhs) noexcept
    requires(b)
{
    T temp = rhs;
    temp *= lhs;
    return temp;
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T operator/(const T& lhs, const T& rhs) noexcept
    requires(b)
{
    T temp = lhs;
    temp /= rhs;
    return temp;
}

/*
 * Careful: This seemingly convenient overload is actually pretty
 * dangerous:
 *
 * The usual operator precedence is violated, i.e., b*a^p is (wrongly)
 * evaluated as (b*a)^a instead of the expected b*(a^p).
 */
template <class T, bool b = std::is_base_of_v<Base, T>>
T operator^(T base, int exponent) noexcept
    requires(b)
{
    return sqm<T>(base, exponent);
}

template <class T, bool b = std::is_base_of_v<Base, T>>
T& operator>>(const T& lhs, T& rhs) noexcept
    requires(b)
{
    rhs = lhs;
    return rhs;
}

/*
 * rational numbers
 */

template <class T = long long int>  // use InfInt for more precision... and bad performance
class Rationals : public Field<Rationals<T>> {
   public:
    /* constructors/destructor */
    Rationals(int n = 0, int d = 1);
    Rationals(const Rationals& other) noexcept = default;
    Rationals(Rationals&& other) noexcept = default;
    ~Rationals() noexcept = default;

    /* assignment operators */
    Rationals& operator=(int l) noexcept;
    Rationals& operator=(const Rationals& rhs) noexcept = default;
    Rationals& operator=(Rationals&& rhs) noexcept = default;

    /* comparison */
    bool operator==(const Rationals<T>& rhs) const noexcept {
        return numerator * rhs.get_denominator() == rhs.get_numerator() * denominator;
    }
    bool operator!=(const Rationals<T>& rhs) const noexcept { return !(*this == rhs); }

    /* operations */
    Rationals operator+() const noexcept { return *this; }
    Rationals operator-() const& noexcept;
    Rationals& operator-() && noexcept;

    /* operational assignments */
    Rationals& operator+=(const Rationals& rhs) noexcept;
    Rationals& operator-=(const Rationals& rhs) noexcept;
    Rationals& operator*=(const Rationals& rhs) noexcept;
    Rationals& operator/=(const Rationals& rhs);

    /* randomization */
    void randomize();
    void randomize_force_change();

    /* getters */
    uint16_t get_multiplicative_order();
    uint16_t get_additive_order() noexcept;
    std::string get_unique_ID() const noexcept { return std::to_string(numerator) + "/" + std::to_string(denominator); }
    static std::string get_info() noexcept { return "rational number"; }
    static constexpr uint16_t get_characteristic() noexcept { return 0; }

    /* properties */
    bool has_positive_sign() const {
        return (numerator >= 0 && denominator > 0) || (numerator <= 0 && denominator < 0);
    }

    bool is_zero() const { return numerator == 0; }

    auto get_numerator() const noexcept { return numerator; }
    auto get_denominator() const noexcept { return denominator; }

    /* simplify/greatest common factor */
    void simplify() noexcept;

   private:
    T numerator;
    T denominator;
};

/* member functions for Rationals */

template <class T>
inline Rationals<T>::Rationals(int n, int d) : numerator(n), denominator(d) {
    if (d == 0) throw std::invalid_argument("denominator must not be zero");
    simplify();
}

template <class T>
Rationals<T>& Rationals<T>::operator=(int l) noexcept {
    this->numerator = l;
    this->denominator = 1;
    return *this;
}

template <class T>
inline Rationals<T> Rationals<T>::operator-() const& noexcept {
    Rationals res(*this);
    res.numerator = -res.numerator;
    return res;
}

template <class T>
inline Rationals<T>& Rationals<T>::operator-() && noexcept {
    numerator = -numerator;
    return *this;
}

template <class T>
inline Rationals<T>& Rationals<T>::operator+=(const Rationals& rhs) noexcept {
    auto tn = numerator * rhs.get_denominator() + denominator * rhs.get_numerator();
    auto td = denominator * rhs.get_denominator();
    numerator = tn;
    denominator = td;
    simplify();
    return *this;
}

template <class T>
inline Rationals<T>& Rationals<T>::operator-=(const Rationals& rhs) noexcept {
    auto tn = numerator * rhs.get_denominator() - denominator * rhs.get_numerator();
    auto td = denominator * rhs.get_denominator();
    numerator = tn;
    denominator = td;
    simplify();
    return *this;
}

template <class T>
inline Rationals<T>& Rationals<T>::operator*=(const Rationals& rhs) noexcept {
    auto tn = numerator * rhs.get_numerator();
    auto td = denominator * rhs.get_denominator();
    numerator = tn;
    denominator = td;
    simplify();
    return *this;
}

template <class T>
inline Rationals<T>& Rationals<T>::operator/=(const Rationals& rhs) {
    if (rhs.numerator == 0) throw std::invalid_argument("division by zero");
    auto tn = numerator * rhs.get_denominator();
    auto td = denominator * rhs.get_numerator();
    numerator = tn;
    denominator = td;
    simplify();
    return *this;
}

template <class T>
inline void Rationals<T>::randomize() {
    static std::uniform_int_distribution<T> dist(-10, 10);
    numerator = dist(gen);
    do {
        denominator = dist(gen);
    } while (denominator == 0);
    simplify();
}

template <class T>
inline void Rationals<T>::randomize_force_change() {
    static std::uniform_int_distribution<T> dist(-10, 10);
    T n;
    T d;
    do {
        n = dist(gen);
        do {
            d = dist(gen);
        } while (d == 0);
    } while (T(n) * denominator == numerator * T(d));
    numerator = n;
    denominator = d;
}

template <class T>
inline uint16_t Rationals<T>::get_multiplicative_order() {
    if (numerator == 0)
        throw std::invalid_argument(
            "trying to calculate multiplicative order "
            "of additive neutral element");
    if (numerator == denominator) {
        return 1;
    }
    return 0;
}

template <class T>
inline uint16_t Rationals<T>::get_additive_order() noexcept {
    if (numerator == 0) {
        return 1;
    }
    return 0;
}

template <class T>
inline void Rationals<T>::simplify() noexcept {
    auto d = GCD<>(numerator, denominator);
    numerator /= d;
    denominator /= d;
    if (denominator < 0) {
        numerator *= -1;
        denominator *= -1;
    }
}

/* free functions wrt. Rationals */

template <class T>
inline std::ostream& operator<<(std::ostream& os, const Rationals<T>& e) noexcept {
    std::string temp = std::to_string(e.get_numerator());
    if (e.get_denominator() != 1) temp += "/" + std::to_string(e.get_denominator());
    os << temp;  // single call to << in order to make previous std::setw()
                 // work
    return os;
}

/*
 * prime fields
 */

template <uint16_t p, uint8_t m = 1>
using label_t = typename std::conditional_t<sqm<uint32_t>(p, m) < 256, uint8_t, uint16_t>;

template <uint16_t p>
class Fp : public Field<Fp<p>> {
    static_assert(isPrime(p) && p >= 2, "p is not a prime larger than one");

   public:
    /* constructors/destructor */
    Fp() noexcept;
    Fp(int l);
    Fp(const Fp& other) noexcept : label(other.label) {}
    Fp(Fp&& other) noexcept : label(other.label) {}
    ~Fp() noexcept override = default;

    /* assignment operators */
    Fp& operator=(int l) noexcept override;
    Fp& operator=(const Fp& rhs) noexcept override;
    Fp& operator=(Fp&& rhs) noexcept override;

    /* comparison */
    bool operator==(const Fp& rhs) const noexcept override { return label == rhs.get_label(); }
    bool operator!=(const Fp& rhs) const noexcept override { return label != rhs.get_label(); }

    /* operations */
    Fp operator+() const noexcept override { return *this; }
    Fp operator-() const& noexcept override;
    Fp& operator-() && noexcept override;

    /* operational assignments */
    Fp& operator+=(const Fp& rhs) noexcept override;
    Fp& operator-=(const Fp& rhs) noexcept override;
    Fp& operator*=(const Fp& rhs) noexcept override;
    Fp& operator*=(uint16_t s) noexcept;
    Fp& operator/=(const Fp& rhs) override;

    /* randomization */
    void randomize() override;
    void randomize_force_change() override;

    /* getters */
    uint16_t get_multiplicative_order() override;
    uint16_t get_additive_order() noexcept override;
    std::string get_unique_ID() const noexcept override { return std::to_string(label); }
    static std::string get_info() noexcept { return "prime field with " + std::to_string(p) + " elements"; }
    static constexpr uint16_t get_characteristic() noexcept { return p; }
    label_t<p> get_label() const noexcept { return label; }

    static constexpr Fp get_generator() noexcept { return p == 2 ? Fp(1) : Fp(2); }
    static constexpr uint16_t get_p() noexcept { return p; }
    // static constexpr uint8_t get_m() noexcept { return 1; }
    static constexpr uint16_t get_m() noexcept { return 1; }
    static constexpr uint32_t get_q() noexcept { return p; }
    static constexpr uint32_t get_size() noexcept { return p; }

    static void show_tables() noexcept;

    /* properties */
    bool has_positive_sign() const override { return true; }
    bool is_zero() const override { return label == 0; }

   private:
    label_t<p> label;

    uint16_t calculateMultiplicativeOrder();

#ifdef USE_LUTS_FOR_FP
    struct Lut1D {
        label_t<p> values[p]{};
    };
    struct Lut2D {
        label_t<p> values[p][p]{};
    };

    static constexpr Lut2D lut_add = []() constexpr -> Lut2D {
        Lut2D lut_add;
        for (uint16_t i = 0; i < p; ++i) {
            for (uint16_t j = 0; j < p; ++j) {
                lut_add.values[i][j] = (i + j) % p;
            }
        }
        return lut_add;
    }();

    static constexpr Lut1D lut_neg = []() constexpr -> Lut1D {
        Lut1D lut_neg;
        lut_neg.values[0] = 0;
        for (uint16_t i = 1; i < p; ++i) {
            lut_neg.values[i] = p - i;
        }
        return lut_neg;
    }();

    static constexpr Lut2D lut_mul = []() constexpr -> Lut2D {
        Lut2D lut_mul;
        for (uint16_t i = 0; i < p; ++i) {
            for (uint16_t j = 0; j < p; ++j) {
                lut_mul.values[i][j] = (i * j) % p;
            }
        }
        return lut_mul;
    }();

    static constexpr Lut1D lut_inv = []() constexpr -> Lut1D {
        Lut1D lut_inv;
        lut_inv.values[0] = 0;
        for (uint16_t i = 1; i < p; ++i) {
            int s = modinv<int, p>(i);
            if (s <= -(int)p || s >= (int)p) s %= (int)p;
            if (s < 0) s += (int)p;
            lut_inv.values[i] = s;
        }
        return lut_inv;
    }();

    static constexpr Lut1D lut_mul_ord = []() constexpr -> Lut1D {
        Lut1D lut_mul_ord;

        lut_mul_ord.values[0] = 0;
        lut_mul_ord.values[1] = 1;
        for (uint16_t i = 2; i < p; ++i) {
            uint16_t temp = i;
            for (uint16_t j = 1; j < p; ++j) {
                if (temp == 1) {
                    lut_mul_ord.values[i] = j;
                    break;
                }
                temp = lut_mul.values[temp][i];
            }
        }

        return lut_mul_ord;
    }();
#endif
};

/* member functions for Fp */

template <uint16_t p>
inline Fp<p>::Fp() noexcept : label(0) {
    static_assert(isPrime(p) && p >= 2, "p is not a prime larger than one");
}

template <uint16_t p>
inline Fp<p>::Fp(int l) {
    static_assert(isPrime(p) && p >= 2, "p is not a prime larger than one");
    if (l <= -(int)p || l >= (int)p) l %= (int)p;
    if (l < 0) l += (int)p;
    label = l;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator=(int l) noexcept {
    Fp temp(l);
    std::swap(*this, temp);
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator=(const Fp& rhs) noexcept {
    if (*this == rhs) return *this;
    label = rhs.label;
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator=(Fp&& rhs) noexcept {
    if (*this == rhs) return *this;
    label = std::move(rhs.label);
    return *this;
}

template <uint16_t p>
inline Fp<p> Fp<p>::operator-() const& noexcept {
    Fp res(*this);
    if (res.label != 0) {
#ifndef USE_LUTS_FOR_FP
        int temp = -(int)res.label + (int)p;
        res.label = temp;
#else
        res.label = lut_neg.values[res.label];
#endif
    }
    return res;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator-() && noexcept {
    if (label != 0) {
#ifndef USE_LUTS_FOR_FP
        label = -(int)label + (int)p;
#else
        label = lut_neg.values[label];
#endif
    }
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator+=(const Fp& rhs) noexcept {
#ifndef USE_LUTS_FOR_FP
    int temp = label + rhs.get_label();
    if (temp < p)
        label = temp;
    else
        label = temp - p;
#else
    label = lut_add.values[label][rhs.get_label()];
#endif
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator-=(const Fp& rhs) noexcept {
#ifndef USE_LUTS_FOR_FP
    int temp = (int)label - (int)rhs.get_label();
    if (temp >= 0)
        label = temp;
    else
        label = temp + p;
#else
    label = lut_add.values[label][lut_neg.values[rhs.get_label()]];
#endif
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator*=(const Fp& rhs) noexcept {
#ifndef USE_LUTS_FOR_FP
    int temp = label * rhs.get_label();
    if (temp < p)
        label = temp;
    else
        label = temp % p;
#else
    label = lut_mul.values[label][rhs.get_label()];
#endif
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator*=(uint16_t s) noexcept {
    if (get_characteristic() != 0) {
        s = s % get_characteristic();
    }
    Fp res(0);
    for (size_t i = 0; i < s; ++i) {
        res += *this;
    }
    *this = std::move(res);
    return *this;
}

template <uint16_t p>
inline Fp<p>& Fp<p>::operator/=(const Fp& rhs) {
    if (rhs.label == 0) throw std::invalid_argument("trying to divide by zero");
#ifndef USE_LUTS_FOR_FP
    int s;
    int t;
    GCD<int>(rhs.get_label(), p, &s, &t);
    *this *= Fp(s);
#else
    label = lut_mul.values[label][lut_inv.values[rhs.get_label()]];
#endif
    return *this;
}

template <uint16_t p>
inline void Fp<p>::randomize() {
    static std::uniform_int_distribution<int> dist(0, p - 1);
#ifndef USE_LUTS_FOR_FP
    int temp = label + dist(gen);
    if (temp < p)
        label = temp;
    else
        label = temp - p;

#else
    label = lut_add.values[label][dist(gen)];
#endif
}

template <uint16_t p>
inline void Fp<p>::randomize_force_change() {
    static std::uniform_int_distribution<int> dist(1, p - 1);
#ifndef USE_LUTS_FOR_FP
    int temp = label + dist(gen);
    if (temp < p)
        label = temp;
    else
        label = temp - p;

#else
    label = lut_add.values[label][dist(gen)];
#endif
}

template <uint16_t p>
inline uint16_t Fp<p>::get_multiplicative_order() {
    if (label == 0)
        throw std::invalid_argument(
            "trying to calculate multiplicative order "
            "of additive neutral element");
#ifndef USE_LUTS_FOR_FP
    return calculateMultiplicativeOrder();
#else
    return lut_mul_ord.values[label];
#endif
}

template <uint16_t p>
inline uint16_t Fp<p>::get_additive_order() noexcept {
    if (label == 0) {
        return 1;
    }
    return p;
}

template <uint16_t p>
inline void Fp<p>::show_tables() noexcept {
    std::cout << "addition table (row and column headers omitted)" << std::endl;
    for (uint16_t i = 0; i < p; ++i) {
        for (uint16_t j = 0; j < p; ++j) {
#ifndef USE_LUTS_FOR_FP
            std::cout << (i + j) % p << ", ";
#else
            std::cout << (int)lut_add.values[i][j] << ", ";
#endif
        }
        std::cout << std::endl;
    }

    std::cout << "multiplication table (row and column headers omitted)" << std::endl;
    for (uint16_t i = 0; i < p; ++i) {
        for (uint16_t j = 0; j < p; ++j) {
#ifndef USE_LUTS_FOR_FP
            std::cout << (i * j) % p << ", ";
#else
            std::cout << (int)lut_mul.values[i][j] << ", ";
#endif
        }
        std::cout << std::endl;
    }
}

template <uint16_t p>
inline uint16_t Fp<p>::calculateMultiplicativeOrder() {
    if (*this == Fp(0))
        throw std::invalid_argument(
            "trying to calculate multiplicative order "
            "of additive neutral element");
    label_t<p> i = 1;
    Fp temp(*this);
    const Fp one(1);
    for (;;) {
        if (temp == one) {
            return i;
        }
        temp *= *this;
        ++i;
    }
    return i;
}

/* free functions wrt. Fp */

template <uint16_t p>
std::ostream& operator<<(std::ostream& os, const Fp<p>& e) noexcept {
    os << (int64_t)e.get_label();
    return os;
}

/*
 * prime extension fields
 */

template <uint16_t p, uint8_t m, size_t SIZE>
static uint32_t constexpr integer_from_coeffs(const std::array<int64_t, SIZE>& coeffs) noexcept {
    uint32_t res = coeffs[0];
    uint32_t t = p;
    for (uint8_t i = 1; i < m; ++i) {
        res += coeffs[i] * t;
        t *= p;
    }
    return res;
}

#define MOD std::array

template <uint16_t p, MOD modulus>
class Fq : public Field<Fq<p, modulus>> {
    static_assert(isPrime(p) && p >= 2, "p is not a prime larger than one");
    static_assert(modulus.front() == 1, "provided polynomial is not monic");

   protected:
    static constexpr uint8_t m = modulus.size() - 1;
    static constexpr label_t<p, m> Q = sqm<uint32_t>(p, m);

   public:
    /* constructors/destructor */
    Fq() noexcept : label(0) {}
    Fq(int l);
    Fq(const Fq& other) noexcept : label(other.label) {}
    Fq(Fq&& other) noexcept : label(std::move(other.label)) {}
    template <class S, typename = std::enable_if_t<std::is_base_of_v<Fq, S>>>
    Fq(const Vector<S>& other);
    ~Fq() noexcept = default;

    /* assignment operators */
    Fq& operator=(int l);
    Fq& operator=(const Fq& rhs) noexcept;
    Fq& operator=(Fq&& rhs) noexcept;
    template <class S, typename = std::enable_if_t<std::is_base_of_v<Fq, S>>>
    Fq& operator=(const Vector<S>& rhs);

    /* comparison */
    bool operator==(const Fq& rhs) const noexcept { return label == rhs.get_label(); }
    bool operator!=(const Fq& rhs) const noexcept { return label != rhs.get_label(); }

    /* operations */
    Fq operator+() const noexcept { return *this; }
    Fq operator-() const& noexcept;
    Fq& operator-() && noexcept;

    /* operational assignments */
    Fq& operator+=(const Fq& rhs) noexcept;
    template <uint8_t M>
    Fq& operator+=(const SF<Fq, M>& rhs) noexcept;
    Fq& operator-=(const Fq& rhs) noexcept;
    template <uint8_t M>
    Fq& operator-=(const SF<Fq, M>& rhs) noexcept;
    Fq& operator*=(const Fq& rhs) noexcept;
    template <uint8_t M>
    Fq& operator*=(const SF<Fq, M>& rhs) noexcept;
    Fq& operator*=(uint16_t s) noexcept;
    Fq& operator/=(const Fq& rhs);
    template <uint8_t M>
    Fq& operator/=(const SF<Fq, M>& rhs);

    /* randomization */
    void randomize();
    void randomize_force_change();

    /* getters */
    uint16_t get_multiplicative_order();
    uint16_t get_additive_order() noexcept { return lut_add_ord.values[label]; }
    std::string get_unique_ID() const noexcept { return std::to_string(label); }
    static std::string get_info() noexcept;
    static constexpr uint16_t get_characteristic() noexcept { return p; }
    label_t<p, m> get_label() const noexcept { return label; }
    template <class S>
    static constexpr Polynomial<S> get_modulus() noexcept;

    static constexpr Fq get_generator() noexcept { return Fq(g.value); }
    static constexpr uint16_t get_p() noexcept { return p; }
    static constexpr uint8_t get_m() noexcept { return m; }
    // static constexpr uint8_t get_m() noexcept { return m; }
    static constexpr uint32_t get_q() noexcept { return Q; }
    static constexpr uint32_t get_size() noexcept { return Q; }

    static void show_tables() noexcept;

    /* properties */
    bool has_positive_sign() const { return true; }
    bool is_zero() const { return label == 0; }

    /* element as vector over subfield */
    template <class S>
    Vector<S> as_vector() const noexcept;

   private:
    struct Gen {
        label_t<p, m> value{};
    };
    struct Lut1D {
        // label_t<p, m> values[Q]{};
        std::array<label_t<p, m>, Q> values{};
    };

    struct Lut2D {
        constexpr label_t<p, m>& operator()(size_t i, size_t j) {
            if (i > j) return operator()(j, i);
            if constexpr (Q < COMPRESS_LUTS_FROM_Q) {
                return values[i][j];
            } else {
                if (i > floor_constexpr(Q / 2.0)) {
                    return values[Q - i][j - i];
                } else {
                    return values[i][j];
                }
            }
        }
        constexpr const label_t<p, m> operator()(size_t i, size_t j) const {
            if (i > j) return operator()(j, i);
            if constexpr (Q < COMPRESS_LUTS_FROM_Q) {
                return values[i][j];
            } else {
                if (i > floor_constexpr(Q / 2.0)) {
                    return values[Q - i][j - i];
                } else {
                    return values[i][j];
                }
            }
        }
        std::array<std::array<label_t<p, m>, Q>,
                   (Q < COMPRESS_LUTS_FROM_Q ? Q : static_cast<label_t<p, m>>(floor_constexpr(Q / 2.0))) + 1>
            values{};
    };
    struct Lut2Dcoeff {
        // label_t<p, 1> values[Q][m]{};
        std::array<std::array<label_t<p, 1>, m>, Q> values{};
    };

   public:
    static constexpr Lut2Dcoeff lut_coeff = []() constexpr -> Lut2Dcoeff {
        Lut2Dcoeff lut_coeff;

        // calculate base-p representation of all labels (MSB right)
        for (uint32_t i = 0; i < Q; ++i) {
            lut_coeff.values[i][m - 1] = i % p;
            uint32_t t = p;
            for (uint8_t s = 1; s < m; ++s) {
                lut_coeff.values[i][m - 1 - s] = (i / t) % p;
                t *= p;
            }
        }

        return lut_coeff;
    }();

   private:
    static constexpr Lut2D lut_add = []() constexpr -> Lut2D {
        Lut2D lut_add;

        for (label_t<p, m> i = 0; i < Q; ++i) {
            lut_add(0, i) = i;
            lut_add(i, 0) = i;
        }

        for (uint32_t i = 1; i < Q; ++i) {
            for (uint32_t j = i; j < Q; ++j) {
                // uint16_t temp[m] = {0};
                std::array<int64_t, m> temp{};

                for (uint16_t s = 0; s < m; ++s) {
                    temp[s] = (lut_coeff.values[i][m - 1 - s] + lut_coeff.values[j][m - 1 - s]) % p;
                }

                lut_add(i, j) = integer_from_coeffs<p, m>(temp);
                // lut_add.values[j][i] = lut_add.values[i][j];  // symmetry along main diagonal
            }
        }

        return lut_add;
    }();

   protected:
    label_t<p, m> label;

    static constexpr Lut2D lut_mul = []() constexpr -> Lut2D {
        Lut2D lut_mul;

        for (uint16_t i = 0; i < Q; ++i) {
            lut_mul(0, i) = 0;
            lut_mul(i, 0) = 0;
            lut_mul(1, i) = i;
            lut_mul(i, 1) = i;
        }

        for (uint16_t i = 2; i < Q; ++i) {
            const auto lhs = lut_coeff.values[i];

            // calculate degree of lhs polynomial
            uint8_t lhs_deg = m - 1;
            for (uint8_t s = 0; s < m; ++s) {
                if (lhs[s] != 0)
                    break;
                else
                    --lhs_deg;
            }

            for (uint16_t j = i; j < Q; ++j) {
                const auto rhs = lut_coeff.values[j];

                // calculate degree of rhs polynomial
                uint8_t rhs_deg = m - 1;
                for (uint8_t t = 0; t < m; ++t) {
                    if (rhs[t] != 0)
                        break;
                    else
                        --rhs_deg;
                }

                // int64_t temp[2 * m - 1]{0};
                std::array<int64_t, 2 * m - 1> temp{};

                // polynomial multiplication (main performance bottleneck)
                for (uint8_t s = 0; s <= lhs_deg; ++s) {
                    const auto S = lhs[m - 1 - s];
                    if (S == 0) continue;
                    for (uint8_t t = 0; t <= rhs_deg; ++t) {
                        const auto T = rhs[m - 1 - t];
                        // if (T == 0) continue;
                        temp[s + t] = (temp[s + t] + S * T) % p;
                    }
                }

                // reduction wrt. modulus
                for (uint16_t s = 0; s < m - 1; ++s) {
                    const int64_t flag = temp[2 * m - 2 - s];
                    if (flag == 0) continue;
                    for (uint16_t t = 0; t <= m; ++t) {
                        if (modulus[m - t] == 0) continue;
                        temp[2 * m - 2 - (s + t)] = (temp[2 * m - 2 - (s + t)] - flag * modulus[m - t]) % (int64_t)p;
                        if (temp[2 * m - 2 - (s + t)] < 0) temp[2 * m - 2 - (s + t)] += (int64_t)p;
                    }
                }

                lut_mul(i, j) = integer_from_coeffs<p, m>(temp);
                if (lut_mul(i, j) == 0) {
                    throw "* ERROR - Fq requires an irreducible modulus MOD! *";
                }
                // lut_mul.values[j][i] = lut_mul.values[i][j];  // symmetry along main diagonal
            }
        }

        return lut_mul;
    }();

    static constexpr Lut1D lut_neg = []() constexpr -> Lut1D {
        Lut1D lut_neg;
        lut_neg.values[0] = 0;
        for (uint16_t i = 1; i < Q; ++i) {
            if (lut_neg.values[i] != 0) continue;
            for (uint16_t j = i; j < Q; ++j) {
                if (lut_add(i, j) == 0) {
                    lut_neg.values[i] = j;
                    lut_neg.values[j] = i;
                    break;
                }
            }
        }
        return lut_neg;
    }();

   private:
    static constexpr Lut1D lut_inv = []() constexpr -> Lut1D {
        Lut1D lut_inv;

        lut_inv.values[0] = 0;
        for (uint16_t i = 1; i < Q; ++i) {
            if (lut_inv.values[i] != 0) continue;
            for (uint16_t j = i; j < Q; ++j) {
                if (lut_mul(i, j) == 1) {
                    lut_inv.values[i] = j;
                    lut_inv.values[j] = i;
                    break;
                }
            }
        }

        return lut_inv;
    }();

    static constexpr Lut1D lut_mul_ord = []() constexpr -> Lut1D {
        Lut1D lut_mul_ord;

        lut_mul_ord.values[0] = 0;
        lut_mul_ord.values[1] = 1;
        for (uint16_t i = 2; i < Q; ++i) {
            uint16_t temp = i;
            for (uint16_t j = 1; j < Q; ++j) {
                if (temp == 1) {
                    lut_mul_ord.values[i] = j;
                    break;
                }
                temp = lut_mul(temp, i);
            }
        }

        return lut_mul_ord;
    }();

    static constexpr Lut1D lut_add_ord = []() constexpr -> Lut1D {
        Lut1D lut_add_ord;

        lut_add_ord.values[0] = 1;
        for (uint16_t i = 1; i < Q; ++i) {
            uint16_t temp = i;
            for (uint16_t j = 1; j < Q; ++j) {
                if (temp == 0) {
                    lut_add_ord.values[i] = j;
                    break;
                }
                temp = lut_add(temp, i);
            }
        }

        return lut_add_ord;
    }();

   protected:
    static constexpr Gen g = []() constexpr -> Gen {
        Gen g;

        for (uint16_t i = 1; i < Q; ++i) {
            if (lut_mul_ord.values[i] == Q - 1) {
                g.value = i;
                break;
            }
        }

        return g;
    }();
};

/* member functions for Fq */

template <uint16_t p, std::array modulus>
template <class S, typename>
inline Fq<p, modulus>::Fq(const Vector<S>& other) {
    if (m % other.get_n() != 0)
        throw std::invalid_argument("trying to construct base field element from subfield vector of incompatible size");

    label = 0;
    label_t<S::get_p(), S::get_m()> a = 1;
    for (uint32_t i = 0; i < other.get_n(); ++i) {
        label_t<S::get_p(), S::get_m()> l;
        for (label_t<S::get_p(), S::get_m()> j = 0; j < S::get_size(); ++j) {
            if (S::lut_BFlabels.values[j] == other[i].get_label()) {
                l = j;
                break;
            }
        }
        label += a * l;
        a *= sqm<label_t<S::get_p(), m>>(p, S::get_m());
    }
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>::Fq(int l) {
    if (-l >= Q || l >= Q) throw std::invalid_argument("abs(l) must not be larger than p^m");
    if (l < 0)
        label = lut_neg.values[-l];
    else
        label = l;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator=(int l) {
    Fq temp(l);
    std::swap(*this, temp);
    return *this;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator=(const Fq& rhs) noexcept {
    if (*this == rhs) return *this;
    label = rhs.label;
    return *this;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator=(Fq&& rhs) noexcept {
    if (*this == rhs) return *this;
    label = std::move(rhs.label);
    return *this;
}

template <uint16_t p, std::array modulus>
template <class S, typename>
inline Fq<p, modulus>& Fq<p, modulus>::operator=(const Vector<S>& rhs) {
    Fq temp(rhs);
    std::swap(*this, temp);
    return *this;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus> Fq<p, modulus>::operator-() const& noexcept {
    Fq res(*this);
    if (res.label != 0) {
        res.label = lut_neg.values[res.label];
    }
    return res;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator-() && noexcept {
    if (label != 0) {
        label = lut_neg.values[label];
    }
    return *this;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator+=(const Fq& rhs) noexcept {
    label = lut_add(label, rhs.get_label());
    return *this;
}

template <uint16_t p, std::array modulus>
template <uint8_t M>
inline Fq<p, modulus>& Fq<p, modulus>::operator+=(const SF<Fq, M>& rhs) noexcept {
    return *this += rhs.asSuperfieldElement();
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator-=(const Fq& rhs) noexcept {
    label = lut_add(label, lut_neg.values[rhs.get_label()]);
    return *this;
}

template <uint16_t p, std::array modulus>
template <uint8_t M>
inline Fq<p, modulus>& Fq<p, modulus>::operator-=(const SF<Fq, M>& rhs) noexcept {
    return *this -= rhs.asSuperfieldElement();
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator*=(const Fq& rhs) noexcept {
    label = lut_mul(label, rhs.get_label());
    return *this;
}

template <uint16_t p, std::array modulus>
template <uint8_t M>
inline Fq<p, modulus>& Fq<p, modulus>::operator*=(const SF<Fq, M>& rhs) noexcept {
    return *this *= rhs.asSuperfieldElement();
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator*=(uint16_t s) noexcept {
    if (get_characteristic() != 0) {
        s = s % get_characteristic();
    }
    Fq res(0);
    for (size_t i = 0; i < s; ++i) {
        res += *this;
    }
    *this = std::move(res);
    return *this;
}

template <uint16_t p, std::array modulus>
inline Fq<p, modulus>& Fq<p, modulus>::operator/=(const Fq& rhs) {
    if (rhs.label == 0) throw std::invalid_argument("trying to divide by zero");
    label = lut_mul(label, lut_inv.values[rhs.get_label()]);
    return *this;
}

template <uint16_t p, std::array modulus>
template <uint8_t M>
inline Fq<p, modulus>& Fq<p, modulus>::operator/=(const SF<Fq, M>& rhs) {
    return *this /= rhs.asSuperfieldElement();
}

template <uint16_t p, std::array modulus>
inline void Fq<p, modulus>::randomize() {
    static std::uniform_int_distribution<label_t<p, m>> dist(0, Q - 1);
    label = dist(gen);
}

template <uint16_t p, std::array modulus>
inline void Fq<p, modulus>::randomize_force_change() {
    static std::uniform_int_distribution<label_t<p, m>> dist(1, Q - 1);
    label = lut_add(label, dist(gen));
}

template <uint16_t p, std::array modulus>
inline uint16_t Fq<p, modulus>::get_multiplicative_order() {
    if (label == 0)
        throw std::invalid_argument(
            "calculation of multiplicative order "
            "of additive neutral element");
    return lut_mul_ord.values[label];
}

template <uint16_t p, std::array modulus>
inline std::string Fq<p, modulus>::get_info() noexcept {
    std::stringstream ss;
    ss << "finite field with " + std::to_string(Q) + " elements, specified as degree " + std::to_string(m) +
              " extension of prime field with " + std::to_string(p) + " elements, irreducible polynomial ";
    ss << get_modulus<SF<Fq<p, modulus>, 1>>();
    return ss.str();
    /*
size_t i = m;
for (auto it = modulus.cbegin(); it != modulus.cend(); ++it) {
if (*it != 0) {
if (i < m) {
res += " + ";
}
if (*it > 1 || i == 0) res += std::to_string(*it);
if (i > 0) {
if (*it > 1) res += "*";
res += "x";
if (i > 1) {
  res += "^" + std::to_string(i);
}
}
}
--i;
}
*/
}

template <uint16_t p, std::array modulus>
template <class S>
inline constexpr Polynomial<S> Fq<p, modulus>::get_modulus() noexcept {
    Polynomial<S> rho;
    size_t i = 0;
    for (auto it = modulus.cbegin(); it != modulus.cend(); ++it) {
        rho.set_coeff(i, *it);
        ++i;
    }
    return rho;
}

template <uint16_t p, std::array modulus>
inline void Fq<p, modulus>::show_tables() noexcept {
    std::cout << "addition table (row and column headers omitted)" << std::endl;
    /*
    // compressed
    for (uint16_t i = 0; i < (Q < COMPRESS_LUTS_FROM_Q ? Q : static_cast<label_t<p, m>>(floor_constexpr(Q / 2.0))+1);
    ++i) { for (uint16_t j = 0; j < Q; ++j) { std::cout << (int)lut_add.values[i][j] << ", ";
        }
        std::cout << std::endl;
    }
    */
    for (uint16_t i = 0; i < Q; ++i) {
        for (uint16_t j = 0; j < Q; ++j) {
            std::cout << (int)lut_add(i, j) << ", ";
        }
        std::cout << std::endl;
    }

    std::cout << "additive inverse table (row and column headers omitted)" << std::endl;
    for (uint16_t i = 0; i < Q; ++i) {
        std::cout << (int)lut_neg.values[i] << std::endl;
    }

    std::cout << "additive order table (row and column headers "
                 "omitted)"
              << std::endl;
    for (uint16_t i = 0; i < Q; ++i) {
        std::cout << (int)lut_add_ord.values[i] << std::endl;
    }

    std::cout << "multiplication table (row and column headers omitted)" << std::endl;
    /*
    // compressed
    for (uint16_t i = 0; i < (Q < COMPRESS_LUTS_FROM_Q ? Q : static_cast<label_t<p, m>>(floor_constexpr(Q / 2.0))+1);
    ++i) { for (uint16_t j = 0; j < Q; ++j) { std::cout << (int)lut_mul.values[i][j] << ", ";
        }
        std::cout << std::endl;
    }
    */
    for (uint16_t i = 0; i < Q; ++i) {
        for (uint16_t j = 0; j < Q; ++j) {
            std::cout << (int)lut_mul(i, j) << ", ";
        }
        std::cout << std::endl;
    }

    std::cout << "multiplicative inverse table (row and column headers "
                 "omitted)"
              << std::endl;
    for (uint16_t i = 0; i < Q; ++i) {
        std::cout << (int)lut_inv.values[i] << std::endl;
    }

    std::cout << "multiplicative order table (row and column headers "
                 "omitted)"
              << std::endl;
    for (uint16_t i = 0; i < Q; ++i) {
        std::cout << (int)lut_mul_ord.values[i] << std::endl;
    }

    std::cout << "element coefficients table (row and column "
                 "headers omitted)"
              << std::endl;
    for (uint16_t i = 0; i < Q; ++i) {
        std::cout << i << ": ";
        for (uint8_t j = 0; j < m; ++j) {
            std::cout << (int)lut_coeff.values[i][j] << ", ";
        }
        std::cout << std::endl;
    }

    std::cout << "generator (with mult. order)" << std::endl;
    std::cout << (int)g.value << " (" << Fq(g.value).get_multiplicative_order() << ")" << std::endl;
}

template <uint16_t p, std::array modulus>
template <class S>
inline Vector<S> Fq<p, modulus>::as_vector() const noexcept {
    // groups of m0 coefficients from lut_coeff (LSB left) as base-p
    // numbers (MSC left)
    std::array<label_t<S::get_p(), S::get_m()>, m / S::get_m()> basep = {0};  // todo: is this correct? m/S::get_m()?
    for (uint8_t i = 0; i < m; ++i) {
        basep[m / S::get_m() - 1 - i / S::get_m()] +=
            lut_coeff.values[label][i] * sqm<label_t<S::get_p(), m>>(S::get_p(), S::get_m() - 1 - i % S::get_m());
    }

    Vector<S> res(m / S::get_m());
    for (uint8_t i = 0; i < m / S::get_m(); ++i) {
        res.set_component(i, S(basep[i]));
    }

    return res;
}

/* free functions wrt. Fq */
template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator+(const Fq<p, modulus>& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(lhs);
    res += rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator+(Fq<p, modulus>&& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(std::move(lhs));
    res += rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator+(const SF<Fq<p, modulus>, M>& lhs, const Fq<p, modulus>& rhs) noexcept {
    Fq<p, modulus> res(rhs);
    res += lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator+(const SF<Fq<p, modulus>, M>& rhs, Fq<p, modulus>&& lhs) noexcept {
    Fq<p, modulus> res(std::move(rhs));
    res += lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator-(const Fq<p, modulus>& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(lhs);
    res -= rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator-(Fq<p, modulus>&& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(std::move(lhs));
    res -= rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator-(const SF<Fq<p, modulus>, M>& lhs, const Fq<p, modulus>& rhs) noexcept {
    Fq<p, modulus> res(rhs);
    res -= lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator-(const SF<Fq<p, modulus>, M>& rhs, Fq<p, modulus>&& lhs) noexcept {
    Fq<p, modulus> res(std::move(rhs));
    res -= lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator*(const Fq<p, modulus>& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(lhs);
    res *= rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator*(Fq<p, modulus>&& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(std::move(lhs));
    res *= rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator*(const SF<Fq<p, modulus>, M>& lhs, const Fq<p, modulus>& rhs) noexcept {
    Fq<p, modulus> res(rhs);
    res *= lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator*(const SF<Fq<p, modulus>, M>& rhs, Fq<p, modulus>&& lhs) noexcept {
    Fq<p, modulus> res(std::move(rhs));
    res *= lhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator/(const Fq<p, modulus>& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(lhs);
    res /= rhs;
    return res;
}

template <uint16_t p, std::array modulus, uint8_t M>
Fq<p, modulus> operator/(Fq<p, modulus>&& lhs, const SF<Fq<p, modulus>, M>& rhs) noexcept {
    Fq<p, modulus> res(std::move(lhs));
    res /= rhs;
    return res;
}

template <uint16_t p, std::array modulus>
std::ostream& operator<<(std::ostream& os, const Fq<p, modulus>& e) noexcept {
    os << (int64_t)e.get_label();
    /*
    os << " [";
    for (size_t i = 0; i < Fq<p, modulus>::get_m(); ++i) {
        os << (int64_t)Fq<p, modulus>::lut_coeff.values[e.get_label()][i];
    }
    os << "]";
    */
    return os;
}

template <class S, uint8_t m>
class SF;

template <class S, uint8_t m>
std::ostream& operator<<(std::ostream& os, const SF<S, m>& e) noexcept;

/*
 * subfields (of prime extension fields)
 */

template <class S, uint8_t m = 1>
class SF : public S {
    static_assert(isDivisor(S::get_m(), m), "m is not a divisor of m, subfield does not exist");

    friend std::ostream& operator<< <>(std::ostream& os, const SF<S, m>& e) noexcept;

    static constexpr label_t<S::get_p(), m> q = sqm<label_t<S::get_p(), m>>(S::get_p(), m);

   public:
    /* constructors/destructor */
    SF() noexcept = default;
    SF(int l);
    SF(const S& other) {
        if (other.get_label() > S::get_p()) throw std::invalid_argument("not a subfield element");
        S::label = other.get_label();
    }
    SF(const SF& other) = default;
    SF(SF&& other) = default;
    ~SF() noexcept = default;

    /* assignment operators */
    SF& operator=(int l);
    SF& operator=(const SF& rhs) noexcept = default;
    SF& operator=(SF&& rhs) noexcept = default;

    /* randomization */
    void randomize();
    void randomize_force_change();

    /* getters */
    static std::string get_info() noexcept;

    static constexpr SF get_generator() noexcept;
    static constexpr uint8_t get_m() noexcept { return m; }
    static constexpr uint32_t get_size() noexcept { return q; }

    /* element as element of superfield */
    S asSuperfieldElement() const noexcept;

    static void show_tables() noexcept;

   private:
    struct Gen {
        label_t<S::get_p(), S::get_m()> value{};
    };
    struct Lut1D {
        label_t<S::get_p(), S::get_m()> values[q]{};
    };

    static constexpr Gen g = []() constexpr -> Gen {
        Gen g;
        g.value = 1;

        if constexpr (q == 2) return g;

        // h=g^{(p^m−1)/(p^d−1)}, calculate generator h from generator g of superfield
        constexpr auto b = (sqm<uint16_t>(S::get_p(), S::get_m()) - 1) / (sqm<uint16_t>(S::get_p(), m) - 1);
        for (uint16_t i = 0; i < b; ++i) {
            g.value = S::lut_mul(g.value, S::g.value);
        }
        return g;
        /*
                for (uint16_t i = 2; i < S::get_q(); ++i) {
                    label_t<S::get_p(), S::get_m()> t = i;
                    for (uint16_t j = 1; j < q; ++j) {
                        if (t == 1) {
                            if (j == q - 1) {
                                g.value = i;
                                return g;
                            }
                            break;
                        }
                        t = S::lut_mul.values[t][i];
                    }
                }
                return g;  // not reachable
          */
    }();

   public:
    static constexpr Lut1D lut_BFlabels = []() constexpr -> Lut1D {
        Lut1D lut_BFlabels;
        lut_BFlabels.values[0] = 0;
        lut_BFlabels.values[1] = 1;

        if constexpr (q <= 2) {
            return lut_BFlabels;
        } else {
            lut_BFlabels.values[2] = g.value;
            for (label_t<S::get_p(), m> i = 3; i < q; ++i) {
                lut_BFlabels.values[i] = S::lut_mul.values[lut_BFlabels.values[i - 1]][g.value];
            }

            // bubble sort (required for linearity)

            for (label_t<S::get_p(), m> i = 0; i < q - 1; ++i) {
                bool swapped = false;
                for (label_t<S::get_p(), m> j = 0; j < q - i - 1; ++j) {
                    if (lut_BFlabels.values[j] > lut_BFlabels.values[j + 1]) {
                        const label_t<S::get_p(), S::get_m()> temp = lut_BFlabels.values[j];
                        lut_BFlabels.values[j] = lut_BFlabels.values[j + 1];
                        lut_BFlabels.values[j + 1] = temp;
                        swapped = true;
                    }
                }
                if (!swapped) break;
            }

            return lut_BFlabels;
        }
    }();
};

/* member functions for SF */

template <class S, uint8_t m>
inline SF<S, m>::SF(int l) : S() {
    if (-l >= q || l >= q) throw std::invalid_argument("abs(l) must not be larger than p^m");
    if (l < 0)
        S::label = S::lut_neg.values[lut_BFlabels.values[l]];
    else
        S::label = lut_BFlabels.values[l];
}

template <class S, uint8_t m>
inline SF<S, m>& SF<S, m>::operator=(int l) {
    SF temp(l);
    std::swap(*this, temp);
    return *this;
}

template <class S, uint8_t m>
inline void SF<S, m>::randomize() {
    static std::uniform_int_distribution<label_t<S::get_p(), m>> dist(0, q - 1);
    this->label = lut_BFlabels.values[dist(gen)];
}

template <class S, uint8_t m>
inline void SF<S, m>::randomize_force_change() {
    static std::uniform_int_distribution<label_t<S::get_p(), m>> dist(1, q - 1);
    this->label = lut_BFlabels.values[dist(gen)];
}

template <class S, uint8_t m>
inline std::string SF<S, m>::get_info() noexcept {
    return "finite field with " + std::to_string(q) + " elements (as subfield of " + S::get_info() + ")";
}

template <class S, uint8_t m>
inline constexpr SF<S, m> SF<S, m>::get_generator() noexcept {
    SF res;
    res.label = g.value;
    return res;
}

template <class S, uint8_t m>
inline S SF<S, m>::asSuperfieldElement() const noexcept {
    for (label_t<S::get_p(), m> i = 0; i < SF<S, m>::get_size(); ++i) {
        if (SF<S, m>::lut_BFlabels.values[i] == this->label) {
            return S(SF<S, m>::lut_BFlabels.values[i]);
        }
    }
    assert(false);  // should never be here
    return S(0);
}

template <class S, uint8_t m>
inline void SF<S, m>::show_tables() noexcept {
    S::show_tables();

    std::cout << "base field (BF) labels table (row and column "
                 "headers omitted)"
              << std::endl;
    for (label_t<S::get_p(), m> i = 0; i < q; ++i) {
        std::cout << (int)lut_BFlabels.values[i] << std::endl;
    }

    std::cout << "generator (with mult. order)" << std::endl;
    // std::cout << (int)g.value << " (" <<
    // SF(g.value).get_multiplicative_order()
    //           << ")" << std::endl;
    std::cout << get_generator() << " (" << get_generator().get_multiplicative_order() << ")" << std::endl;
}

/* free functions wrt. SF */

template <class S, uint8_t m>
std::ostream& operator<<(std::ostream& os, const SF<S, m>& e) noexcept {
    for (label_t<S::get_p(), m> i = 0; i < SF<S, m>::get_size(); ++i) {
        if (SF<S, m>::lut_BFlabels.values[i] == e.get_label()) {
            os << (int)i;  // << " [" << (int)e.get_label() << "]";
            return os;
        }
    }
    assert(false);  // should never be here
    return os;
}

template <class S, uint8_t m>
Vector<SF<S, m>>& operator>>(const S& lhs, Vector<SF<S, m>>& rhs) noexcept {
    rhs = lhs.template as_vector<SF<S, m>>();
    return rhs;
}

template <uint16_t p>
struct is_finite_field<Fp<p>> : std::true_type {};

template <uint16_t p, std::array modulus>
struct is_finite_field<Fq<p, modulus>> : std::true_type {};

template <uint16_t p, std::array modulus, uint8_t m>
struct is_finite_field<SF<Fq<p, modulus>, m>> : std::true_type {};

}  // namespace ECC

#endif
